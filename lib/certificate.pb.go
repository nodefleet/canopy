// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.6
// 	protoc        v3.19.1
// source: certificate.proto

package lib

import (
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// *****************************************************************************************************
// This file is auto-generated from source files in `/lib/.proto/*` using Protocol Buffers (protobuf)
//
// Protobuf is a language-neutral, platform-neutral serialization format. It allows users
// to define objects in a way that’s both efficient to store and fast to transmit over the network.
// These definitions are compiled into code that *enables different systems and programming languages
// to communicate in a byte-perfect manner*
//
// To update these structures, make changes to the source .proto files, then recompile
// to regenerate this file.
// These auto-generated files are easily recognized by checking for a `.pb.go` ending
// *****************************************************************************************************
// _
// _
// _
// A QuorumCertificate is a collection of signatures from a super-majority of validators that confirms consensus on a
// particular block and results. It serves as proof that enough validators have agreed on the block & result’s validity,
// ensuring its acceptance and security in the blockchain.
type QuorumCertificate struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// header: is the view of the quorum certificate
	Header *View `protobuf:"bytes,1,opt,name=header,proto3" json:"header,omitempty"`
	// results: is the certificate result that Canopy uses to process payments, evidence, swaps, and checkpoints
	Results *CertificateResult `protobuf:"bytes,2,opt,name=results,proto3" json:"results,omitempty"`
	// results_hash: is the cryptographic integrity bytes for results, results hash may be used to confirm the validator
	// quorum signed off on the results
	ResultsHash []byte `protobuf:"bytes,3,opt,name=results_hash,json=resultsHash,proto3" json:"resultHash"` // @gotags: json:"resultHash"
	// block: the proposed block to be added to the blockchain
	Block []byte `protobuf:"bytes,4,opt,name=block,proto3" json:"block,omitempty"`
	// block_hash: is the cryptographic integrity bytes for block, block hash may be used to confirm the validator quorum
	// signed off on the block
	BlockHash []byte `protobuf:"bytes,5,opt,name=block_hash,json=blockHash,proto3" json:"blockHash"` // @gotags: json:"blockHash"
	// proposer_key: is the public key of the block proposer
	ProposerKey []byte `protobuf:"bytes,6,opt,name=proposer_key,json=proposerKey,proto3" json:"proposerKey"` // @gotags: json:"proposerKey"
	// (aggregate) signature: the compact signature created by combining multiple individual signatures from replica
	// validators. This signature serves as a justification that a super-majority quorum signed off on the certificate
	Signature     *AggregateSignature `protobuf:"bytes,7,opt,name=signature,proto3" json:"signature,omitempty"` // aggregate signature from the current proposer message
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *QuorumCertificate) Reset() {
	*x = QuorumCertificate{}
	mi := &file_certificate_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *QuorumCertificate) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*QuorumCertificate) ProtoMessage() {}

func (x *QuorumCertificate) ProtoReflect() protoreflect.Message {
	mi := &file_certificate_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use QuorumCertificate.ProtoReflect.Descriptor instead.
func (*QuorumCertificate) Descriptor() ([]byte, []int) {
	return file_certificate_proto_rawDescGZIP(), []int{0}
}

func (x *QuorumCertificate) GetHeader() *View {
	if x != nil {
		return x.Header
	}
	return nil
}

func (x *QuorumCertificate) GetResults() *CertificateResult {
	if x != nil {
		return x.Results
	}
	return nil
}

func (x *QuorumCertificate) GetResultsHash() []byte {
	if x != nil {
		return x.ResultsHash
	}
	return nil
}

func (x *QuorumCertificate) GetBlock() []byte {
	if x != nil {
		return x.Block
	}
	return nil
}

func (x *QuorumCertificate) GetBlockHash() []byte {
	if x != nil {
		return x.BlockHash
	}
	return nil
}

func (x *QuorumCertificate) GetProposerKey() []byte {
	if x != nil {
		return x.ProposerKey
	}
	return nil
}

func (x *QuorumCertificate) GetSignature() *AggregateSignature {
	if x != nil {
		return x.Signature
	}
	return nil
}

// CertificateResult contains the outcome of a certificate produced by a quorum in consensus
type CertificateResult struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// reward_recipients: the recipients who are rewarded based on the quorum certificate
	// specifically who the committee agreed to reward from the committee treasury
	RewardRecipients *RewardRecipients `protobuf:"bytes,1,opt,name=reward_recipients,json=rewardRecipients,proto3" json:"rewardRecipients"` // @gotags: json:"rewardRecipients"
	// slash_recipients: the recipients who are penalized (slashed) based on the quorum certificate
	// specifically who the committee agreed to slash due to evidence of bad behavior
	SlashRecipients *SlashRecipients `protobuf:"bytes,2,opt,name=slash_recipients,json=slashRecipients,proto3" json:"slashRecipients"` // @gotags: json:"slashRecipients"
	// orders: contains information regarding the 'buying side' of sell orders
	// including actions like 'buy/reserve order' or 'close/complete order'
	Orders *Orders `protobuf:"bytes,3,opt,name=orders,proto3" json:"orders,omitempty"`
	// checkpoint: contains information from the 3rd party chain in order for Canopy to provide Checkpoint-as-a-Service
	Checkpoint *Checkpoint `protobuf:"bytes,4,opt,name=checkpoint,proto3" json:"checkpoint,omitempty"`
	// retired: signals if the committee wants to shut down and mark itself as 'forever unsubsidized' on the root-chain
	Retired       bool `protobuf:"varint,5,opt,name=retired,proto3" json:"retired,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *CertificateResult) Reset() {
	*x = CertificateResult{}
	mi := &file_certificate_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CertificateResult) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CertificateResult) ProtoMessage() {}

func (x *CertificateResult) ProtoReflect() protoreflect.Message {
	mi := &file_certificate_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CertificateResult.ProtoReflect.Descriptor instead.
func (*CertificateResult) Descriptor() ([]byte, []int) {
	return file_certificate_proto_rawDescGZIP(), []int{1}
}

func (x *CertificateResult) GetRewardRecipients() *RewardRecipients {
	if x != nil {
		return x.RewardRecipients
	}
	return nil
}

func (x *CertificateResult) GetSlashRecipients() *SlashRecipients {
	if x != nil {
		return x.SlashRecipients
	}
	return nil
}

func (x *CertificateResult) GetOrders() *Orders {
	if x != nil {
		return x.Orders
	}
	return nil
}

func (x *CertificateResult) GetCheckpoint() *Checkpoint {
	if x != nil {
		return x.Checkpoint
	}
	return nil
}

func (x *CertificateResult) GetRetired() bool {
	if x != nil {
		return x.Retired
	}
	return false
}

// RewardRecipients is the list of recipients who will receive rewards from the committee's treasury pool,
// based on decisions confirmed in a Quorum Certificate
type RewardRecipients struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// payment_percents: the percentage of rewards allocated to each recipient
	PaymentPercents []*PaymentPercents `protobuf:"bytes,1,rep,name=payment_percents,json=paymentPercents,proto3" json:"paymentPercents"` // @gotags: json:"paymentPercents"
	// number_of_samples: (internal processing only) the number of samples used to determine reward distribution
	NumberOfSamples uint64 `protobuf:"varint,2,opt,name=number_of_samples,json=numberOfSamples,proto3" json:"numberOfSamples"` // @gotags: json:"numberOfSamples"
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *RewardRecipients) Reset() {
	*x = RewardRecipients{}
	mi := &file_certificate_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RewardRecipients) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RewardRecipients) ProtoMessage() {}

func (x *RewardRecipients) ProtoReflect() protoreflect.Message {
	mi := &file_certificate_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RewardRecipients.ProtoReflect.Descriptor instead.
func (*RewardRecipients) Descriptor() ([]byte, []int) {
	return file_certificate_proto_rawDescGZIP(), []int{2}
}

func (x *RewardRecipients) GetPaymentPercents() []*PaymentPercents {
	if x != nil {
		return x.PaymentPercents
	}
	return nil
}

func (x *RewardRecipients) GetNumberOfSamples() uint64 {
	if x != nil {
		return x.NumberOfSamples
	}
	return 0
}

// SlashRecipients is the list of recipients who are penalized based on misbehavior, like double signing or bad
// proposing based on a committee agreement confirmed in a Quorum Certificate
type SlashRecipients struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// double_signers: a list of actors who the committee agreed double-signed based on evidence
	DoubleSigners []*DoubleSigner `protobuf:"bytes,1,rep,name=double_signers,json=doubleSigners,proto3" json:"doubleSigners"` // @gotags: json:"doubleSigners"
	// slash_recipients: a list of Validators who should be slashed
	SlashRecipients []*SlashRecipient `protobuf:"bytes,2,rep,name=slash_recipients,json=slashRecipients,proto3" json:"slashRecipients"` // @gotags: json:"slashRecipients"
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *SlashRecipients) Reset() {
	*x = SlashRecipients{}
	mi := &file_certificate_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SlashRecipients) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SlashRecipients) ProtoMessage() {}

func (x *SlashRecipients) ProtoReflect() protoreflect.Message {
	mi := &file_certificate_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SlashRecipients.ProtoReflect.Descriptor instead.
func (*SlashRecipients) Descriptor() ([]byte, []int) {
	return file_certificate_proto_rawDescGZIP(), []int{3}
}

func (x *SlashRecipients) GetDoubleSigners() []*DoubleSigner {
	if x != nil {
		return x.DoubleSigners
	}
	return nil
}

func (x *SlashRecipients) GetSlashRecipients() []*SlashRecipient {
	if x != nil {
		return x.SlashRecipients
	}
	return nil
}

// SlashRecipient is an actor who receives a slash
type SlashRecipient struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// address: the address of the recipient to be slashed
	Address []byte `protobuf:"bytes,1,opt,name=address,proto3" json:"address,omitempty"`
	// percent: the percent of the slash
	Percent       uint64 `protobuf:"varint,2,opt,name=percent,proto3" json:"percent,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SlashRecipient) Reset() {
	*x = SlashRecipient{}
	mi := &file_certificate_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SlashRecipient) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SlashRecipient) ProtoMessage() {}

func (x *SlashRecipient) ProtoReflect() protoreflect.Message {
	mi := &file_certificate_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SlashRecipient.ProtoReflect.Descriptor instead.
func (*SlashRecipient) Descriptor() ([]byte, []int) {
	return file_certificate_proto_rawDescGZIP(), []int{4}
}

func (x *SlashRecipient) GetAddress() []byte {
	if x != nil {
		return x.Address
	}
	return nil
}

func (x *SlashRecipient) GetPercent() uint64 {
	if x != nil {
		return x.Percent
	}
	return 0
}

// Orders: tracks actions related to 'buyer side' activities for sell orders
// The committee monitors the 3rd party chain for actions such as intent to buy, funds sent,
// and funds not sent, and communicates these states to the Canopy chain
type Orders struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// lock_orders: a list of actions where a buyer expresses an intent to purchase an order,
	// often referred to as 'claiming' the order
	LockOrders []*LockOrder `protobuf:"bytes,1,rep,name=lock_orders,json=lockOrders,proto3" json:"lockOrders"` // @gotags: json:"lockOrders"
	// reset_orders: a list of orders where no funds were sent before the deadline,
	// signaling to Canopy to 'un-claim' the order
	ResetOrders [][]byte `protobuf:"bytes,2,rep,name=reset_orders,json=resetOrders,proto3" json:"resetOrders"` // @gotags: json:"resetOrders"
	// close_orders: a list of orders where funds were sent,
	// signaling Canopy to transfer escrowed tokens to the buyer's Canopy address
	CloseOrders   [][]byte `protobuf:"bytes,3,rep,name=close_orders,json=closeOrders,proto3" json:"closeOrders"` // @gotags: json:"closeOrders"
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Orders) Reset() {
	*x = Orders{}
	mi := &file_certificate_proto_msgTypes[5]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Orders) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Orders) ProtoMessage() {}

func (x *Orders) ProtoReflect() protoreflect.Message {
	mi := &file_certificate_proto_msgTypes[5]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Orders.ProtoReflect.Descriptor instead.
func (*Orders) Descriptor() ([]byte, []int) {
	return file_certificate_proto_rawDescGZIP(), []int{5}
}

func (x *Orders) GetLockOrders() []*LockOrder {
	if x != nil {
		return x.LockOrders
	}
	return nil
}

func (x *Orders) GetResetOrders() [][]byte {
	if x != nil {
		return x.ResetOrders
	}
	return nil
}

func (x *Orders) GetCloseOrders() [][]byte {
	if x != nil {
		return x.CloseOrders
	}
	return nil
}

// LockOrder is a buyer expressing an intent to purchase an order, often referred to as 'claiming' the order
type LockOrder struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// order_id: is the number id that is unique to this committee to identify the order
	OrderId []byte `protobuf:"bytes,1,opt,name=order_id,json=orderId,proto3" json:"orderID"` // @gotags: json:"orderID"
	// chain_id: is the id of the committee
	ChainId uint64 `protobuf:"varint,2,opt,name=chain_id,json=chainId,proto3" json:"chainID"` // @gotags: json:"chainID"
	// buyer_receive_address: the Canopy address where the tokens may be received
	BuyerReceiveAddress []byte `protobuf:"bytes,3,opt,name=buyer_receive_address,json=buyerReceiveAddress,proto3" json:"buyerReceiveAddress"` // @gotags: json:"buyerReceiveAddress"
	// buyer_send_address: the 'counter asset' address where the tokens will be sent from
	BuyerSendAddress []byte `protobuf:"bytes,4,opt,name=buyer_send_address,json=buyerSendAddress,proto3" json:"buyerSendAddress"` // @gotags: json:"buyerSendAddress"
	// buyer_chain_deadline: the 'counter asset' chain height at which the buyer must send the 'counter asset' by
	// or the 'intent to buy' will be voided
	BuyerChainDeadline uint64 `protobuf:"varint,5,opt,name=buyer_chain_deadline,json=buyerChainDeadline,proto3" json:"buyerChainDeadline"` // @gotags: json:"buyerChainDeadline"
	unknownFields      protoimpl.UnknownFields
	sizeCache          protoimpl.SizeCache
}

func (x *LockOrder) Reset() {
	*x = LockOrder{}
	mi := &file_certificate_proto_msgTypes[6]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *LockOrder) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*LockOrder) ProtoMessage() {}

func (x *LockOrder) ProtoReflect() protoreflect.Message {
	mi := &file_certificate_proto_msgTypes[6]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use LockOrder.ProtoReflect.Descriptor instead.
func (*LockOrder) Descriptor() ([]byte, []int) {
	return file_certificate_proto_rawDescGZIP(), []int{6}
}

func (x *LockOrder) GetOrderId() []byte {
	if x != nil {
		return x.OrderId
	}
	return nil
}

func (x *LockOrder) GetChainId() uint64 {
	if x != nil {
		return x.ChainId
	}
	return 0
}

func (x *LockOrder) GetBuyerReceiveAddress() []byte {
	if x != nil {
		return x.BuyerReceiveAddress
	}
	return nil
}

func (x *LockOrder) GetBuyerSendAddress() []byte {
	if x != nil {
		return x.BuyerSendAddress
	}
	return nil
}

func (x *LockOrder) GetBuyerChainDeadline() uint64 {
	if x != nil {
		return x.BuyerChainDeadline
	}
	return 0
}

// CloseOrder is a buyer completing the purchase of an order, often referred to as 'buying' the order
type CloseOrder struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// order_id: is the number id that is unique to this committee to identify the order
	OrderId []byte `protobuf:"bytes,1,opt,name=order_id,json=orderId,proto3" json:"orderID"` // @gotags: json:"orderID"
	// chain_id: is the id of the committee
	ChainId uint64 `protobuf:"varint,2,opt,name=chain_id,json=chainId,proto3" json:"chainID"` // @gotags: json:"chainID"
	// close_order: is the tag to represent the intent to embed a close order
	CloseOrder    bool `protobuf:"varint,3,opt,name=close_order,json=closeOrder,proto3" json:"closeOrder"` //@gotags: json:"closeOrder"
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *CloseOrder) Reset() {
	*x = CloseOrder{}
	mi := &file_certificate_proto_msgTypes[7]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CloseOrder) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CloseOrder) ProtoMessage() {}

func (x *CloseOrder) ProtoReflect() protoreflect.Message {
	mi := &file_certificate_proto_msgTypes[7]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CloseOrder.ProtoReflect.Descriptor instead.
func (*CloseOrder) Descriptor() ([]byte, []int) {
	return file_certificate_proto_rawDescGZIP(), []int{7}
}

func (x *CloseOrder) GetOrderId() []byte {
	if x != nil {
		return x.OrderId
	}
	return nil
}

func (x *CloseOrder) GetChainId() uint64 {
	if x != nil {
		return x.ChainId
	}
	return 0
}

func (x *CloseOrder) GetCloseOrder() bool {
	if x != nil {
		return x.CloseOrder
	}
	return false
}

// Checkpoint is 3rd party chain information that allows Canopy to provide Checkpointing-as-a-Service for the 3rd party
// checkpointing is important to prevent `long-range-attacks` in proof of stake blockchains and is currently the
// secure standard
type Checkpoint struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// height: the height of the third party chain
	Height uint64 `protobuf:"varint,1,opt,name=height,proto3" json:"height,omitempty"`
	// block_hash: the cryptographic hash of the third party chain block for the height
	BlockHash     []byte `protobuf:"bytes,2,opt,name=block_hash,json=blockHash,proto3" json:"blockHash"` // @gotags: json:"blockHash"
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Checkpoint) Reset() {
	*x = Checkpoint{}
	mi := &file_certificate_proto_msgTypes[8]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Checkpoint) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Checkpoint) ProtoMessage() {}

func (x *Checkpoint) ProtoReflect() protoreflect.Message {
	mi := &file_certificate_proto_msgTypes[8]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Checkpoint.ProtoReflect.Descriptor instead.
func (*Checkpoint) Descriptor() ([]byte, []int) {
	return file_certificate_proto_rawDescGZIP(), []int{8}
}

func (x *Checkpoint) GetHeight() uint64 {
	if x != nil {
		return x.Height
	}
	return 0
}

func (x *Checkpoint) GetBlockHash() []byte {
	if x != nil {
		return x.BlockHash
	}
	return nil
}

// PaymentPercents represents the distribution of rewards to recipients from the committee treasury pool
// Each recipient is identified by their address and the percentage of the reward they will receive
// Percents are diluted based on how many samples are in the Committee Data
type PaymentPercents struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// address: the address where the tokens will be received
	Address []byte `protobuf:"bytes,1,opt,name=address,proto3" json:"address,omitempty"`
	// percent: the dilutable share of the committee treasury pool
	Percent uint64 `protobuf:"varint,2,opt,name=percent,proto3" json:"percent,omitempty"`
	// chain_id: the chain_id where the payment is distributed
	ChainId       uint64 `protobuf:"varint,3,opt,name=chain_id,json=chainId,proto3" json:"chain_id,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *PaymentPercents) Reset() {
	*x = PaymentPercents{}
	mi := &file_certificate_proto_msgTypes[9]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *PaymentPercents) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*PaymentPercents) ProtoMessage() {}

func (x *PaymentPercents) ProtoReflect() protoreflect.Message {
	mi := &file_certificate_proto_msgTypes[9]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use PaymentPercents.ProtoReflect.Descriptor instead.
func (*PaymentPercents) Descriptor() ([]byte, []int) {
	return file_certificate_proto_rawDescGZIP(), []int{9}
}

func (x *PaymentPercents) GetAddress() []byte {
	if x != nil {
		return x.Address
	}
	return nil
}

func (x *PaymentPercents) GetPercent() uint64 {
	if x != nil {
		return x.Percent
	}
	return 0
}

func (x *PaymentPercents) GetChainId() uint64 {
	if x != nil {
		return x.ChainId
	}
	return 0
}

// DoubleSigner identifies a validator who has been caught double signing and should be slashed
// The structure includes the validator's public key and a list of block heights where the double signing occurred
type DoubleSigner struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// id: the cryptographic identifier of the malicious actor
	// - at the consensus level, this represents the Public_Key of the actor
	// - at the state machine level, this represents the Address of the actor
	Id []byte `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// heights: the list of heights when the infractions occurred
	Heights       []uint64 `protobuf:"varint,2,rep,packed,name=heights,proto3" json:"heights,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DoubleSigner) Reset() {
	*x = DoubleSigner{}
	mi := &file_certificate_proto_msgTypes[10]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DoubleSigner) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DoubleSigner) ProtoMessage() {}

func (x *DoubleSigner) ProtoReflect() protoreflect.Message {
	mi := &file_certificate_proto_msgTypes[10]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DoubleSigner.ProtoReflect.Descriptor instead.
func (*DoubleSigner) Descriptor() ([]byte, []int) {
	return file_certificate_proto_rawDescGZIP(), []int{10}
}

func (x *DoubleSigner) GetId() []byte {
	if x != nil {
		return x.Id
	}
	return nil
}

func (x *DoubleSigner) GetHeights() []uint64 {
	if x != nil {
		return x.Heights
	}
	return nil
}

// CommitteesData is a list of essential information about the committee
type CommitteesData struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	List          []*CommitteeData       `protobuf:"bytes,1,rep,name=list,proto3" json:"list,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *CommitteesData) Reset() {
	*x = CommitteesData{}
	mi := &file_certificate_proto_msgTypes[11]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CommitteesData) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CommitteesData) ProtoMessage() {}

func (x *CommitteesData) ProtoReflect() protoreflect.Message {
	mi := &file_certificate_proto_msgTypes[11]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CommitteesData.ProtoReflect.Descriptor instead.
func (*CommitteesData) Descriptor() ([]byte, []int) {
	return file_certificate_proto_rawDescGZIP(), []int{11}
}

func (x *CommitteesData) GetList() []*CommitteeData {
	if x != nil {
		return x.List
	}
	return nil
}

// CommitteeData is current status information about the current status of the Committee
type CommitteeData struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// chain_id: is the unique identifier of the chain and the committee of Validators responsible for it
	ChainId uint64 `protobuf:"varint,1,opt,name=chain_id,json=chainId,proto3" json:"chainID"` // @gotags: json:"chainID"
	// last_updated_height: is the Canopy height included in the most recently processed Certificate Results transaction
	// This protects against historical committee attacks and ensures sequentiality among committees
	LastRootHeightUpdated uint64 `protobuf:"varint,2,opt,name=last_root_height_updated,json=lastRootHeightUpdated,proto3" json:"lastRootHeightUpdated"` // @gotags: json:"lastRootHeightUpdated"
	// last_chain_height_updated: is the 3rd party chain height included in the most recent processed Certificate Results
	// transaction. This protects against reformatting the replay attacks
	LastChainHeightUpdated uint64 `protobuf:"varint,3,opt,name=last_chain_height_updated,json=lastChainHeightUpdated,proto3" json:"lastChainHeightUpdated"` // @gotags: json:"lastChainHeightUpdated"
	// payment_percents: a list of recipients and the percentage of rewards they will receive, distributed at the end of
	// the block
	PaymentPercents []*PaymentPercents `protobuf:"bytes,4,rep,name=payment_percents,json=paymentPercents,proto3" json:"paymentPercents"` // @gotags: json:"paymentPercents"
	// number_of_samples: the total count of processed Certificate Result Transactions, used to dilute reward percentages
	// accurately
	NumberOfSamples uint64 `protobuf:"varint,5,opt,name=number_of_samples,json=numberOfSamples,proto3" json:"numberOfSamples"` // @gotags: json:"numberOfSamples"
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *CommitteeData) Reset() {
	*x = CommitteeData{}
	mi := &file_certificate_proto_msgTypes[12]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CommitteeData) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CommitteeData) ProtoMessage() {}

func (x *CommitteeData) ProtoReflect() protoreflect.Message {
	mi := &file_certificate_proto_msgTypes[12]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CommitteeData.ProtoReflect.Descriptor instead.
func (*CommitteeData) Descriptor() ([]byte, []int) {
	return file_certificate_proto_rawDescGZIP(), []int{12}
}

func (x *CommitteeData) GetChainId() uint64 {
	if x != nil {
		return x.ChainId
	}
	return 0
}

func (x *CommitteeData) GetLastRootHeightUpdated() uint64 {
	if x != nil {
		return x.LastRootHeightUpdated
	}
	return 0
}

func (x *CommitteeData) GetLastChainHeightUpdated() uint64 {
	if x != nil {
		return x.LastChainHeightUpdated
	}
	return 0
}

func (x *CommitteeData) GetPaymentPercents() []*PaymentPercents {
	if x != nil {
		return x.PaymentPercents
	}
	return nil
}

func (x *CommitteeData) GetNumberOfSamples() uint64 {
	if x != nil {
		return x.NumberOfSamples
	}
	return 0
}

var File_certificate_proto protoreflect.FileDescriptor

const file_certificate_proto_rawDesc = "" +
	"\n" +
	"\x11certificate.proto\x12\x05types\x1a\x0fconsensus.proto\"\xa0\x02\n" +
	"\x11QuorumCertificate\x12#\n" +
	"\x06header\x18\x01 \x01(\v2\v.types.ViewR\x06header\x122\n" +
	"\aresults\x18\x02 \x01(\v2\x18.types.CertificateResultR\aresults\x12!\n" +
	"\fresults_hash\x18\x03 \x01(\fR\vresultsHash\x12\x14\n" +
	"\x05block\x18\x04 \x01(\fR\x05block\x12\x1d\n" +
	"\n" +
	"block_hash\x18\x05 \x01(\fR\tblockHash\x12!\n" +
	"\fproposer_key\x18\x06 \x01(\fR\vproposerKey\x127\n" +
	"\tsignature\x18\a \x01(\v2\x19.types.AggregateSignatureR\tsignature\"\x90\x02\n" +
	"\x11CertificateResult\x12D\n" +
	"\x11reward_recipients\x18\x01 \x01(\v2\x17.types.RewardRecipientsR\x10rewardRecipients\x12A\n" +
	"\x10slash_recipients\x18\x02 \x01(\v2\x16.types.SlashRecipientsR\x0fslashRecipients\x12%\n" +
	"\x06orders\x18\x03 \x01(\v2\r.types.OrdersR\x06orders\x121\n" +
	"\n" +
	"checkpoint\x18\x04 \x01(\v2\x11.types.CheckpointR\n" +
	"checkpoint\x12\x18\n" +
	"\aretired\x18\x05 \x01(\bR\aretired\"\x81\x01\n" +
	"\x10RewardRecipients\x12A\n" +
	"\x10payment_percents\x18\x01 \x03(\v2\x16.types.PaymentPercentsR\x0fpaymentPercents\x12*\n" +
	"\x11number_of_samples\x18\x02 \x01(\x04R\x0fnumberOfSamples\"\x8f\x01\n" +
	"\x0fSlashRecipients\x12:\n" +
	"\x0edouble_signers\x18\x01 \x03(\v2\x13.types.DoubleSignerR\rdoubleSigners\x12@\n" +
	"\x10slash_recipients\x18\x02 \x03(\v2\x15.types.SlashRecipientR\x0fslashRecipients\"D\n" +
	"\x0eSlashRecipient\x12\x18\n" +
	"\aaddress\x18\x01 \x01(\fR\aaddress\x12\x18\n" +
	"\apercent\x18\x02 \x01(\x04R\apercent\"\x81\x01\n" +
	"\x06Orders\x121\n" +
	"\vlock_orders\x18\x01 \x03(\v2\x10.types.LockOrderR\n" +
	"lockOrders\x12!\n" +
	"\freset_orders\x18\x02 \x03(\fR\vresetOrders\x12!\n" +
	"\fclose_orders\x18\x03 \x03(\fR\vcloseOrders\"\xd5\x01\n" +
	"\tLockOrder\x12\x19\n" +
	"\border_id\x18\x01 \x01(\fR\aorderId\x12\x19\n" +
	"\bchain_id\x18\x02 \x01(\x04R\achainId\x122\n" +
	"\x15buyer_receive_address\x18\x03 \x01(\fR\x13buyerReceiveAddress\x12,\n" +
	"\x12buyer_send_address\x18\x04 \x01(\fR\x10buyerSendAddress\x120\n" +
	"\x14buyer_chain_deadline\x18\x05 \x01(\x04R\x12buyerChainDeadline\"c\n" +
	"\n" +
	"CloseOrder\x12\x19\n" +
	"\border_id\x18\x01 \x01(\fR\aorderId\x12\x19\n" +
	"\bchain_id\x18\x02 \x01(\x04R\achainId\x12\x1f\n" +
	"\vclose_order\x18\x03 \x01(\bR\n" +
	"closeOrder\"C\n" +
	"\n" +
	"Checkpoint\x12\x16\n" +
	"\x06height\x18\x01 \x01(\x04R\x06height\x12\x1d\n" +
	"\n" +
	"block_hash\x18\x02 \x01(\fR\tblockHash\"`\n" +
	"\x0fPaymentPercents\x12\x18\n" +
	"\aaddress\x18\x01 \x01(\fR\aaddress\x12\x18\n" +
	"\apercent\x18\x02 \x01(\x04R\apercent\x12\x19\n" +
	"\bchain_id\x18\x03 \x01(\x04R\achainId\"8\n" +
	"\fDoubleSigner\x12\x0e\n" +
	"\x02id\x18\x01 \x01(\fR\x02id\x12\x18\n" +
	"\aheights\x18\x02 \x03(\x04R\aheights\":\n" +
	"\x0eCommitteesData\x12(\n" +
	"\x04list\x18\x01 \x03(\v2\x14.types.CommitteeDataR\x04list\"\x8d\x02\n" +
	"\rCommitteeData\x12\x19\n" +
	"\bchain_id\x18\x01 \x01(\x04R\achainId\x127\n" +
	"\x18last_root_height_updated\x18\x02 \x01(\x04R\x15lastRootHeightUpdated\x129\n" +
	"\x19last_chain_height_updated\x18\x03 \x01(\x04R\x16lastChainHeightUpdated\x12A\n" +
	"\x10payment_percents\x18\x04 \x03(\v2\x16.types.PaymentPercentsR\x0fpaymentPercents\x12*\n" +
	"\x11number_of_samples\x18\x05 \x01(\x04R\x0fnumberOfSamplesB&Z$github.com/canopy-network/canopy/libb\x06proto3"

var (
	file_certificate_proto_rawDescOnce sync.Once
	file_certificate_proto_rawDescData []byte
)

func file_certificate_proto_rawDescGZIP() []byte {
	file_certificate_proto_rawDescOnce.Do(func() {
		file_certificate_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_certificate_proto_rawDesc), len(file_certificate_proto_rawDesc)))
	})
	return file_certificate_proto_rawDescData
}

var file_certificate_proto_msgTypes = make([]protoimpl.MessageInfo, 13)
var file_certificate_proto_goTypes = []any{
	(*QuorumCertificate)(nil),  // 0: types.QuorumCertificate
	(*CertificateResult)(nil),  // 1: types.CertificateResult
	(*RewardRecipients)(nil),   // 2: types.RewardRecipients
	(*SlashRecipients)(nil),    // 3: types.SlashRecipients
	(*SlashRecipient)(nil),     // 4: types.SlashRecipient
	(*Orders)(nil),             // 5: types.Orders
	(*LockOrder)(nil),          // 6: types.LockOrder
	(*CloseOrder)(nil),         // 7: types.CloseOrder
	(*Checkpoint)(nil),         // 8: types.Checkpoint
	(*PaymentPercents)(nil),    // 9: types.PaymentPercents
	(*DoubleSigner)(nil),       // 10: types.DoubleSigner
	(*CommitteesData)(nil),     // 11: types.CommitteesData
	(*CommitteeData)(nil),      // 12: types.CommitteeData
	(*View)(nil),               // 13: types.View
	(*AggregateSignature)(nil), // 14: types.AggregateSignature
}
var file_certificate_proto_depIdxs = []int32{
	13, // 0: types.QuorumCertificate.header:type_name -> types.View
	1,  // 1: types.QuorumCertificate.results:type_name -> types.CertificateResult
	14, // 2: types.QuorumCertificate.signature:type_name -> types.AggregateSignature
	2,  // 3: types.CertificateResult.reward_recipients:type_name -> types.RewardRecipients
	3,  // 4: types.CertificateResult.slash_recipients:type_name -> types.SlashRecipients
	5,  // 5: types.CertificateResult.orders:type_name -> types.Orders
	8,  // 6: types.CertificateResult.checkpoint:type_name -> types.Checkpoint
	9,  // 7: types.RewardRecipients.payment_percents:type_name -> types.PaymentPercents
	10, // 8: types.SlashRecipients.double_signers:type_name -> types.DoubleSigner
	4,  // 9: types.SlashRecipients.slash_recipients:type_name -> types.SlashRecipient
	6,  // 10: types.Orders.lock_orders:type_name -> types.LockOrder
	12, // 11: types.CommitteesData.list:type_name -> types.CommitteeData
	9,  // 12: types.CommitteeData.payment_percents:type_name -> types.PaymentPercents
	13, // [13:13] is the sub-list for method output_type
	13, // [13:13] is the sub-list for method input_type
	13, // [13:13] is the sub-list for extension type_name
	13, // [13:13] is the sub-list for extension extendee
	0,  // [0:13] is the sub-list for field type_name
}

func init() { file_certificate_proto_init() }
func file_certificate_proto_init() {
	if File_certificate_proto != nil {
		return
	}
	file_consensus_proto_init()
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_certificate_proto_rawDesc), len(file_certificate_proto_rawDesc)),
			NumEnums:      0,
			NumMessages:   13,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_certificate_proto_goTypes,
		DependencyIndexes: file_certificate_proto_depIdxs,
		MessageInfos:      file_certificate_proto_msgTypes,
	}.Build()
	File_certificate_proto = out.File
	file_certificate_proto_goTypes = nil
	file_certificate_proto_depIdxs = nil
}
